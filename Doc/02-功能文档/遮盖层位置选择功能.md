# ?? 遮盖层位置选择功能

> **文档版本**: 1.0  
> **创建日期**: 2025-01-02 20:00:00  
> **最后更新**: 2025-01-02 20:00:00  
> **功能状态**: ? 已完成

---

## ?? 功能概述

遮盖层位置选择功能允许用户为每个软件待办项自定义悬浮窗的显示位置，支持6种预设位置和精确的偏移量调整。

### 核心特性

- ? **6种预设位置** - 支持左上、右上、左下、右下、居中、窗口下方
- ? **精确偏移调整** - 支持X轴和Y轴的像素级偏移
- ? **拖拽保存** - 支持直接拖拽悬浮窗并自动保存新位置
- ? **DPI自适应** - 自动处理不同DPI缩放下的位置计算
- ? **边界保护** - 确保悬浮窗不会超出屏幕边界
- ? **继承机制** - 子待办项自动继承父级的位置设置

---

## ?? 使用方法

### 方法一：编辑窗口设置

1. 双击或右键编辑软件待办项
2. 展开"?? 应用绑定设置"分组
3. 在"遮盖层位置"下拉框中选择预设位置：
   - **窗口下方** - 悬浮窗显示在目标窗口底部（默认）
   - **左上角** - 悬浮窗显示在目标窗口左上角
   - **右上角** - 悬浮窗显示在目标窗口右上角
   - **左下角** - 悬浮窗显示在目标窗口左下角
   - **右下角** - 悬浮窗显示在目标窗口右下角
   - **居中** - 悬浮窗显示在目标窗口中央

4. 在"偏移量调整"中设置X/Y轴的偏移量（-1000到1000像素）：
   - **X轴偏移** - 正值向右，负值向左
   - **Y轴偏移** - 正值向下，负值向上

5. 点击"?? 保存"应用设置

### 方法二：直接拖拽

1. 启动软件待办项的注入功能
2. 当悬浮窗显示时，用鼠标左键按住悬浮窗
3. 拖动到期望的位置
4. 松开鼠标，新位置会自动保存

> **?? 提示**: 拖拽方式会自动计算偏移量并更新所有相关待办项的设置

---

## ?? 技术实现

### 数据模型

#### TodoItem.cs

```csharp
/// <summary>
/// 遮盖层位置枚举
/// </summary>
public enum OverlayPosition
{
    [Description("窗口下方")]
    Bottom = 0,
    [Description("左上角")]
    TopLeft = 1,
    [Description("右上角")]
    TopRight = 2,
    [Description("左下角")]
    BottomLeft = 3,
    [Description("右下角")]
    BottomRight = 4,
    [Description("居中")]
    Center = 5
}

/// <summary>
/// 遮盖层位置（默认：窗口下方）
/// </summary>
public OverlayPosition OverlayPosition { get; set; } = OverlayPosition.Bottom;

/// <summary>
/// 遮盖层X轴偏移量（像素）
/// </summary>
public double OverlayOffsetX { get; set; } = 0;

/// <summary>
/// 遮盖层Y轴偏移量（像素）
/// </summary>
public double OverlayOffsetY { get; set; } = 0;
```

### 位置计算算法

#### MainWindowViewModel.cs - UpdateOverlayPosition方法

```csharp
private static void UpdateOverlayPosition(OverlayWindow overlayWindow, IntPtr targetWindowHandle, TodoItemModel item)
{
    if (Utils.NativeMethods.GetWindowRect(targetWindowHandle, out var rect))
    {
        // 获取DPI缩放因子并转换坐标
        var source = PresentationSource.FromVisual(overlayWindow);
        if (source?.CompositionTarget != null)
        {
            Matrix transformMatrix = source.CompositionTarget.TransformFromDevice;

            double targetLeft = rect.Left * transformMatrix.M11;
            double targetTop = rect.Top * transformMatrix.M22;
            double targetRight = rect.Right * transformMatrix.M11;
            double targetBottom = rect.Bottom * transformMatrix.M22;
            double targetWidth = targetRight - targetLeft;
            double targetHeight = targetBottom - targetTop;

            double left = 0, top = 0;

            // 根据配置的位置计算坐标
            switch (item.OverlayPosition)
            {
                case OverlayPosition.Bottom:
                    left = targetLeft;
                    top = targetBottom - overlayWindow.ActualHeight;
                    break;

                case OverlayPosition.TopLeft:
                    left = targetLeft;
                    top = targetTop;
                    break;

                case OverlayPosition.TopRight:
                    left = targetRight - overlayWindow.ActualWidth;
                    top = targetTop;
                    break;

                case OverlayPosition.BottomLeft:
                    left = targetLeft;
                    top = targetBottom - overlayWindow.ActualHeight;
                    break;

                case OverlayPosition.BottomRight:
                    left = targetRight - overlayWindow.ActualWidth;
                    top = targetBottom - overlayWindow.ActualHeight;
                    break;

                case OverlayPosition.Center:
                    left = targetLeft + (targetWidth - overlayWindow.ActualWidth) / 2;
                    top = targetTop + (targetHeight - overlayWindow.ActualHeight) / 2;
                    break;
            }

            // 边界保护
            double adjustedLeft = Math.Max(0, left);
            double adjustedTop = Math.Max(0, top);

            // 应用偏移量
            overlayWindow.Left = adjustedLeft + item.OverlayOffsetX;
            overlayWindow.Top = adjustedTop + item.OverlayOffsetY;
        }
    }
}
```

### 拖拽保存功能

#### OverlayWindow.xaml.cs

```csharp
private bool _isDragging = false;
private double _initialLeft;
private double _initialTop;

private void Window_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
{
    _isDragging = true;
    _initialLeft = this.Left;
    _initialTop = this.Top;
    
    this.MouseMove += Window_MouseMove;
    this.MouseLeftButtonUp += Window_MouseLeftButtonUp;
    
    DragMove();
}

private void Window_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
{
    if (_isDragging)
    {
        _isDragging = false;
        this.MouseMove -= Window_MouseMove;
        this.MouseLeftButtonUp -= Window_MouseLeftButtonUp;
        
        SaveNewOffset();
    }
}

private void SaveNewOffset()
{
    if (TodoItems == null || TodoItems.Count == 0) return;

    var rootItem = TodoItems[0];
    if (rootItem == null || string.IsNullOrEmpty(rootItem.AppPath)) return;

    // 计算偏移量变化
    double deltaX = this.Left - _initialLeft;
    double deltaY = this.Top - _initialTop;

    // 更新所有相关待办项的偏移量
    UpdateOffsetForAllItems(App.MainViewModel?.Model?.TodoItems, rootItem.AppPath, deltaX, deltaY);
}
```

---

## ?? 使用场景

### 场景1：底部任务栏式布局
```
用途: 显示快速待办清单
位置: 窗口下方
偏移: X=0, Y=0
```

### 场景2：侧边栏提醒
```
用途: 不干扰主内容区
位置: 右上角
偏移: X=-20, Y=50（避开标题栏）
```

### 场景3：中央强提醒
```
用途: 重要任务提醒
位置: 居中
偏移: X=0, Y=-100（略微上移）
```

### 场景4：角落待办清单
```
用途: 保持可见但不干扰
位置: 左下角
偏移: X=10, Y=-10（留出边距）
```

---

## ?? 注意事项

### 1. 子待办项继承
- ? 子待办项**不能**单独设置位置
- ? 自动继承父级（根待办项）的位置设置
- ? 编辑窗口中子待办项的位置设置被禁用

### 2. 多屏幕支持
- ? 支持多显示器环境
- ? DPI缩放自动适配
- ?? 边界检查确保不会超出屏幕

### 3. 性能优化
- ? 位置更新频率：100ms（定时器间隔）
- ? 拖拽时只计算一次偏移量
- ? 批量更新所有相关待办项

---

## ?? 常见问题

### Q1: 为什么拖拽后位置没有保存？

**A**: 确保：
1. 待办项已经正确注入（IsInjected = true）
2. 软件正在运行并且窗口可见
3. 查看调试输出确认保存逻辑执行

### Q2: 悬浮窗位置不准确怎么办？

**A**: 可能原因：
1. DPI缩放设置：尝试重启应用
2. 多显示器配置：检查目标窗口所在显示器
3. 手动调整偏移量进行微调

### Q3: 子待办项能否有不同的位置？

**A**: 不能。设计上子待办项必须和父级保持一致，确保悬浮窗的统一性。如需不同位置，应创建独立的根级待办项。

---

## ?? 版本历史

### v1.0 (2025-01-02)
- ? 实现6种预设位置
- ? 实现X/Y偏移量调整
- ? 实现拖拽保存功能
- ? 实现DPI自适应
- ? 实现边界保护
- ? 实现子待办项继承机制

---

## ?? 相关文档

- [交接文档-最新版](../00-必读/交接文档-最新版.md)
- [项目状态总览](../00-必读/项目状态总览.md)
- [Session-05执行清单](../06-规划文档/Session-05-执行清单.md)

---

**文档版本**: 1.0  
**创建日期**: 2025-01-02 20:00:00  
**维护人**: AI Agent  
**状态**: 已完成 ?
