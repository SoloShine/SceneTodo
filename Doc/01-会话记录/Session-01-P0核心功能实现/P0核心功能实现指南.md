# P0核心功能实现指南

本文档提供缺失P0功能的详细实现指导，供AI Agent和开发者快速参考。

---

## 1. 优先级功能实现

### 1.1 创建优先级枚举
**文件**: `Models/Priority.cs`
```csharp
using System.ComponentModel;

namespace SceneTodo.Models
{
    public enum Priority
    {
        [Description("低")]
        Low = 0,
        
        [Description("中")]
        Medium = 1,
        
        [Description("高")]
        High = 2
    }
}
```

### 1.2 修改TodoItem模型
**文件**: `Models/TodoItem.cs`
添加字段：
```csharp
private Priority priority = Priority.Medium;
/// <summary>
/// 优先级
/// </summary>
public Priority Priority
{
    get => priority;
    set
    {
        if (priority != value)
        {
            priority = value;
            UpdatedAt = DateTime.Now;
            OnPropertyChanged(nameof(Priority));
        }
    }
}
```

### 1.3 数据库迁移
**文件**: `Services/Database/TodoDbContext.cs`
在 `OnModelCreating` 中添加默认值配置：
```csharp
modelBuilder.Entity<TodoItem>()
    .Property(t => t.Priority)
    .HasDefaultValue(Priority.Medium);
```

### 1.4 编辑界面添加优先级选择
**文件**: `Views/EditTodoItemWindow.xaml`
添加ComboBox：
```xml
<TextBlock Text="优先级：" Grid.Row="X" Grid.Column="0" />
<ComboBox x:Name="PriorityComboBox" 
          Grid.Row="X" Grid.Column="1"
          ItemsSource="{Binding Converter={converters:EnumToComboBoxConverter}, ConverterParameter={x:Type models:Priority}}"
          DisplayMemberPath="Value"
          SelectedValuePath="Key" />
```

### 1.5 遮盖层样式区分
**文件**: `Views/OverlayWindow.xaml` 或 `Views/TodoItemControl.xaml`
添加样式转换器：
```csharp
// Converters/PriorityToBorderBrushConverter.cs
public class PriorityToBorderBrushConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (value is Priority priority)
        {
            return priority switch
            {
                Priority.High => new SolidColorBrush(Colors.Red),
                Priority.Medium => new SolidColorBrush(Colors.Yellow),
                Priority.Low => new SolidColorBrush(Colors.Gray),
                _ => new SolidColorBrush(Colors.Transparent)
            };
        }
        return new SolidColorBrush(Colors.Transparent);
    }
    
    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}
```

在XAML中使用：
```xml
<Border BorderBrush="{Binding Priority, Converter={StaticResource PriorityToBorderBrushConverter}}"
        BorderThickness="2">
    <!-- 待办内容 -->
</Border>
```

---

## 2. 关联操作功能实现

### 2.1 创建关联操作模型
**文件**: `Models/LinkedAction.cs`
```csharp
namespace SceneTodo.Models
{
    public enum LinkedActionType
    {
        OpenUrl,      // 打开网页
        OpenFile,     // 打开文件
        LaunchApp     // 启动应用
    }
    
    public class LinkedAction
    {
        public string Id { get; set; } = Guid.NewGuid().ToString();
        public LinkedActionType ActionType { get; set; }
        public string DisplayName { get; set; } = string.Empty;
        public string ActionTarget { get; set; } = string.Empty;  // URL/文件路径/应用路径
    }
}
```

### 2.2 修改TodoItem模型
**文件**: `Models/TodoItem.cs`
添加关联操作字段：
```csharp
private string linkedActionsJson = "[]";
/// <summary>
/// 关联操作JSON字符串
/// </summary>
public string LinkedActionsJson
{
    get => linkedActionsJson;
    set
    {
        if (linkedActionsJson != value)
        {
            linkedActionsJson = value;
            OnPropertyChanged(nameof(LinkedActionsJson));
        }
    }
}

// 在TodoItemModel中添加便捷属性
[JsonIgnore]
public ObservableCollection<LinkedAction> LinkedActions
{
    get
    {
        try
        {
            return JsonSerializer.Deserialize<ObservableCollection<LinkedAction>>(LinkedActionsJson) 
                   ?? new ObservableCollection<LinkedAction>();
        }
        catch
        {
            return new ObservableCollection<LinkedAction>();
        }
    }
    set
    {
        LinkedActionsJson = JsonSerializer.Serialize(value);
        OnPropertyChanged(nameof(LinkedActions));
    }
}
```

### 2.3 执行关联操作
**文件**: `ViewModels/MainWindowViewModel.cs`
添加命令：
```csharp
public ICommand ExecuteLinkedActionCommand { get; }

// 在构造函数中
ExecuteLinkedActionCommand = new RelayCommand(ExecuteLinkedAction);

private void ExecuteLinkedAction(object? parameter)
{
    if (parameter is not LinkedAction action) return;
    
    try
    {
        switch (action.ActionType)
        {
            case LinkedActionType.OpenUrl:
                Process.Start(new ProcessStartInfo(action.ActionTarget) 
                { 
                    UseShellExecute = true 
                });
                break;
                
            case LinkedActionType.OpenFile:
                if (File.Exists(action.ActionTarget))
                {
                    Process.Start(new ProcessStartInfo(action.ActionTarget) 
                    { 
                        UseShellExecute = true 
                    });
                }
                else
                {
                    MessageBox.Show($"文件不存在: {action.ActionTarget}");
                }
                break;
                
            case LinkedActionType.LaunchApp:
                if (File.Exists(action.ActionTarget))
                {
                    Process.Start(action.ActionTarget);
                }
                else
                {
                    MessageBox.Show($"应用不存在: {action.ActionTarget}");
                }
                break;
        }
    }
    catch (Exception ex)
    {
        MessageBox.Show($"执行操作失败: {ex.Message}");
    }
}
```

### 2.4 UI显示关联操作
**文件**: `Views/TodoItemControl.xaml`
添加按钮列表：
```xml
<ItemsControl ItemsSource="{Binding LinkedActions}">
    <ItemsControl.ItemTemplate>
        <DataTemplate>
            <Button Content="{Binding DisplayName}"
                    Command="{Binding DataContext.ExecuteLinkedActionCommand, 
                             RelativeSource={RelativeSource AncestorType=UserControl}}"
                    CommandParameter="{Binding}"
                    Margin="2" />
        </DataTemplate>
    </ItemsControl.ItemTemplate>
</ItemsControl>
```

---

## 3. 历史记录功能实现

### 3.1 创建历史记录窗口
**文件**: `Views/HistoryWindow.xaml`
```xml
<hc:Window x:Class="SceneTodo.Views.HistoryWindow"
           xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
           xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
           xmlns:hc="https://handyorg.github.io/handycontrol"
           Title="历史记录" Height="600" Width="800">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>
        
        <!-- 筛选栏 -->
        <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="10">
            <hc:DatePicker x:Name="StartDatePicker" Width="150" Margin="5"/>
            <TextBlock Text="至" VerticalAlignment="Center" Margin="5"/>
            <hc:DatePicker x:Name="EndDatePicker" Width="150" Margin="5"/>
            <Button Content="筛选" Click="FilterButton_Click" Margin="5"/>
        </StackPanel>
        
        <!-- 历史记录列表 -->
        <DataGrid Grid.Row="1" 
                  x:Name="HistoryDataGrid"
                  AutoGenerateColumns="False"
                  IsReadOnly="True">
            <DataGrid.Columns>
                <DataGridTextColumn Header="内容" Binding="{Binding Content}" Width="*"/>
                <DataGridTextColumn Header="完成时间" Binding="{Binding CompletedAt}" Width="150"/>
                <DataGridTextColumn Header="分类" Binding="{Binding Category}" Width="100"/>
            </DataGrid.Columns>
        </DataGrid>
    </Grid>
</hc:Window>
```

### 3.2 历史记录ViewModel
**文件**: `ViewModels/HistoryWindowViewModel.cs`
```csharp
public class HistoryWindowViewModel : INotifyPropertyChanged
{
    public event PropertyChangedEventHandler? PropertyChanged;
    
    private ObservableCollection<TodoItemModel> historyItems = new();
    public ObservableCollection<TodoItemModel> HistoryItems
    {
        get => historyItems;
        set
        {
            historyItems = value;
            OnPropertyChanged(nameof(HistoryItems));
        }
    }
    
    public async Task LoadHistoryAsync(DateTime? startDate = null, DateTime? endDate = null)
    {
        var allItems = await App.TodoItemRepository.GetAllAsync();
        var completed = allItems.Where(t => t.IsCompleted);
        
        if (startDate.HasValue)
            completed = completed.Where(t => t.CompletedAt >= startDate.Value);
            
        if (endDate.HasValue)
            completed = completed.Where(t => t.CompletedAt <= endDate.Value);
        
        HistoryItems = new ObservableCollection<TodoItemModel>(
            completed.Select(t => new TodoItemModel(t))
        );
    }
    
    protected virtual void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
```

### 3.3 添加菜单入口
**文件**: `MainWindow.xaml`
在菜单中添加：
```xml
<Button Content="历史记录" Command="{Binding ShowHistoryCommand}" />
```

在MainWindowViewModel中：
```csharp
public ICommand ShowHistoryCommand { get; }

// 构造函数中
ShowHistoryCommand = new RelayCommand(ShowHistory);

private void ShowHistory(object? parameter)
{
    var historyWindow = new HistoryWindow();
    historyWindow.ShowDialog();
}
```

---

## 4. 数据备份与恢复功能

### 4.1 创建备份服务
**文件**: `Services/BackupService.cs`
```csharp
public class BackupService
{
    public async Task<string> ExportBackupAsync(string backupPath = null)
    {
        if (string.IsNullOrEmpty(backupPath))
        {
            backupPath = Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments),
                $"SceneTodo_Backup_{DateTime.Now:yyyyMMdd_HHmmss}.json"
            );
        }
        
        var allTodos = await App.TodoItemRepository.GetAllAsync();
        var allAutoTasks = await App.AutoTaskRepository.GetAllAsync();
        
        var backup = new
        {
            ExportTime = DateTime.Now,
            Version = "1.0",
            TodoItems = allTodos,
            AutoTasks = allAutoTasks,
            Settings = App.MainViewModel?.Model
        };
        
        var json = JsonSerializer.Serialize(backup, new JsonSerializerOptions 
        { 
            WriteIndented = true 
        });
        
        await File.WriteAllTextAsync(backupPath, json);
        
        return backupPath;
    }
    
    public async Task<bool> ImportBackupAsync(string backupPath)
    {
        if (!File.Exists(backupPath))
            return false;
            
        try
        {
            var json = await File.ReadAllTextAsync(backupPath);
            var backup = JsonSerializer.Deserialize<BackupData>(json);
            
            if (backup == null)
                return false;
            
            // 清空现有数据（可选，可以让用户选择）
            // 导入待办事项
            foreach (var todo in backup.TodoItems)
            {
                await App.TodoItemRepository.AddAsync(todo);
            }
            
            // 导入自动任务
            foreach (var task in backup.AutoTasks)
            {
                await App.AutoTaskRepository.AddAsync(task);
            }
            
            return true;
        }
        catch
        {
            return false;
        }
    }
}

public class BackupData
{
    public DateTime ExportTime { get; set; }
    public string Version { get; set; }
    public List<TodoItem> TodoItems { get; set; }
    public List<AutoTask> AutoTasks { get; set; }
    public MainWindowModel Settings { get; set; }
}
```

### 4.2 添加UI入口
**文件**: `MainWindow.xaml`
```xml
<Button Content="导出备份" Command="{Binding ExportBackupCommand}" />
<Button Content="导入备份" Command="{Binding ImportBackupCommand}" />
```

在MainWindowViewModel中：
```csharp
public ICommand ExportBackupCommand { get; }
public ICommand ImportBackupCommand { get; }
private readonly BackupService backupService = new();

// 构造函数中
ExportBackupCommand = new RelayCommand(ExportBackup);
ImportBackupCommand = new RelayCommand(ImportBackup);

private async void ExportBackup(object? parameter)
{
    try
    {
        var backupPath = await backupService.ExportBackupAsync();
        MessageBox.Show($"备份成功！\n文件位置: {backupPath}", "成功");
    }
    catch (Exception ex)
    {
        MessageBox.Show($"备份失败: {ex.Message}", "错误");
    }
}

private async void ImportBackup(object? parameter)
{
    var openFileDialog = new OpenFileDialog
    {
        Filter = "JSON文件 (*.json)|*.json",
        Title = "选择备份文件"
    };
    
    if (openFileDialog.ShowDialog() == true)
    {
        var result = MessageBox.Show(
            "导入备份将覆盖现有数据，是否继续？",
            "警告",
            MessageBoxButton.YesNo,
            MessageBoxImage.Warning
        );
        
        if (result == MessageBoxResult.Yes)
        {
            try
            {
                bool success = await backupService.ImportBackupAsync(openFileDialog.FileName);
                if (success)
                {
                    MessageBox.Show("导入成功！", "成功");
                    // 重新加载数据
                    Model.TodoItems = MainWindowModel.LoadFromDatabase();
                }
                else
                {
                    MessageBox.Show("导入失败！", "错误");
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"导入失败: {ex.Message}", "错误");
            }
        }
    }
}
```

---

## 5. 遮盖层位置选择功能

### 5.1 添加位置枚举
**文件**: `Models/OverlayPosition.cs`
```csharp
public enum OverlayPosition
{
    Bottom = 0,      // 下方（默认）
    TopLeft = 1,     // 左上
    TopRight = 2,    // 右上
    BottomLeft = 3,  // 左下
    BottomRight = 4, // 右下
    Center = 5       // 居中
}
```

### 5.2 修改TodoItem模型
添加字段：
```csharp
private OverlayPosition overlayPosition = OverlayPosition.Bottom;
public OverlayPosition OverlayPosition
{
    get => overlayPosition;
    set
    {
        if (overlayPosition != value)
        {
            overlayPosition = value;
            OnPropertyChanged(nameof(OverlayPosition));
        }
    }
}

private double overlayOffsetX = 0;
public double OverlayOffsetX { get; set; }

private double overlayOffsetY = 0;
public double OverlayOffsetY { get; set; }
```

### 5.3 修改UpdateOverlayPosition方法
**文件**: `ViewModels/MainWindowViewModel.cs`
```csharp
private static void UpdateOverlayPosition(OverlayWindow overlayWindow, IntPtr targetWindowHandle, TodoItemModel item)
{
    if (!Utils.NativeMethods.GetWindowRect(targetWindowHandle, out var rect))
        return;
        
    var source = PresentationSource.FromVisual(overlayWindow);
    if (source?.CompositionTarget == null)
        return;
        
    Matrix transformMatrix = source.CompositionTarget.TransformFromDevice;
    
    double targetLeft = rect.Left * transformMatrix.M11;
    double targetTop = rect.Top * transformMatrix.M22;
    double targetRight = rect.Right * transformMatrix.M11;
    double targetBottom = rect.Bottom * transformMatrix.M22;
    double targetWidth = targetRight - targetLeft;
    double targetHeight = targetBottom - targetTop;
    
    double left = 0, top = 0;
    
    switch (item.OverlayPosition)
    {
        case OverlayPosition.Bottom:
            left = targetLeft;
            top = targetBottom - overlayWindow.ActualHeight;
            break;
            
        case OverlayPosition.TopLeft:
            left = targetLeft;
            top = targetTop;
            break;
            
        case OverlayPosition.TopRight:
            left = targetRight - overlayWindow.ActualWidth;
            top = targetTop;
            break;
            
        case OverlayPosition.BottomLeft:
            left = targetLeft;
            top = targetBottom - overlayWindow.ActualHeight;
            break;
            
        case OverlayPosition.BottomRight:
            left = targetRight - overlayWindow.ActualWidth;
            top = targetBottom - overlayWindow.ActualHeight;
            break;
            
        case OverlayPosition.Center:
            left = targetLeft + (targetWidth - overlayWindow.ActualWidth) / 2;
            top = targetTop + (targetHeight - overlayWindow.ActualHeight) / 2;
            break;
    }
    
    // 应用偏移量
    overlayWindow.Left = left + item.OverlayOffsetX;
    overlayWindow.Top = top + item.OverlayOffsetY;
}
```

### 5.4 添加位置选择UI
**文件**: `Views/EditTodoItemWindow.xaml`
```xml
<TextBlock Text="悬浮窗位置：" Grid.Row="X" Grid.Column="0" />
<ComboBox x:Name="OverlayPositionComboBox" 
          Grid.Row="X" Grid.Column="1"
          SelectedValue="{Binding OverlayPosition}">
    <ComboBoxItem Content="窗口下方" Tag="0"/>
    <ComboBoxItem Content="左上角" Tag="1"/>
    <ComboBoxItem Content="右上角" Tag="2"/>
    <ComboBoxItem Content="左下角" Tag="3"/>
    <ComboBoxItem Content="右下角" Tag="4"/>
    <ComboBoxItem Content="居中" Tag="5"/>
</ComboBox>
```

---

## 6. 折叠/展开功能实现

### 6.1 添加折叠状态字段
**文件**: `Models/OverlayWindowState.cs`（或在TodoItem中添加）
```csharp
private bool isOverlayCollapsed = false;
public bool IsOverlayCollapsed
{
    get => isOverlayCollapsed;
    set
    {
        if (isOverlayCollapsed != value)
        {
            isOverlayCollapsed = value;
            OnPropertyChanged(nameof(IsOverlayCollapsed));
        }
    }
}
```

### 6.2 修改OverlayWindow
**文件**: `Views/OverlayWindow.xaml`
```xml
<Border x:Name="MainBorder" Background="AntiqueWhite" CornerRadius="10" Opacity="0.3">
    <DockPanel>
        <!-- 标题栏：始终显示 -->
        <StackPanel DockPanel.Dock="Top" Orientation="Horizontal">
            <Button Content="" x:Name="ToggleButton" Click="ToggleButton_Click" />
            <TextBlock Text="待办事项" Margin="5" />
            <TextBlock x:Name="CountBadge" Text="{Binding TodoCount}" Margin="5" />
        </StackPanel>
        
        <!-- 待办列表：可折叠 -->
        <TreeView x:Name="TodoTreeView"
                  Background="Transparent"
                  DockPanel.Dock="Bottom"
                  ItemsSource="{Binding TodoItems}"
                  Visibility="{Binding IsCollapsed, Converter={StaticResource BoolToVisibilityConverter}}">
            <!-- TreeView内容 -->
        </TreeView>
    </DockPanel>
</Border>
```

**文件**: `Views/OverlayWindow.xaml.cs`
```csharp
private bool isCollapsed = false;

private void ToggleButton_Click(object sender, RoutedEventArgs e)
{
    isCollapsed = !isCollapsed;
    
    if (isCollapsed)
    {
        TodoTreeView.Visibility = Visibility.Collapsed;
        ToggleButton.Content = "?";
        this.Height = 40;  // 只显示标题栏的高度
    }
    else
    {
        TodoTreeView.Visibility = Visibility.Visible;
        ToggleButton.Content = "";
        this.Height = 200;  // 恢复完整高度
    }
}
```

---

## 7. 分类标签功能实现

### 7.1 简单实现（单分类）
**文件**: `Models/TodoItem.cs`
```csharp
private string category = string.Empty;
public string Category
{
    get => category;
    set
    {
        if (category != value)
        {
            category = value;
            OnPropertyChanged(nameof(Category));
        }
    }
}
```

### 7.2 高级实现（多标签）
**文件**: `Models/TodoItem.cs`
```csharp
private string tagsJson = "[]";
public string TagsJson
{
    get => tagsJson;
    set
    {
        if (tagsJson != value)
        {
            tagsJson = value;
            OnPropertyChanged(nameof(TagsJson));
        }
    }
}

// 在TodoItemModel中
[JsonIgnore]
public ObservableCollection<string> Tags
{
    get
    {
        try
        {
            return JsonSerializer.Deserialize<ObservableCollection<string>>(TagsJson) 
                   ?? new ObservableCollection<string>();
        }
        catch
        {
            return new ObservableCollection<string>();
        }
    }
    set
    {
        TagsJson = JsonSerializer.Serialize(value);
        OnPropertyChanged(nameof(Tags));
    }
}
```

### 7.3 分类管理UI
**文件**: `Views/CategoryManagerWindow.xaml`
创建一个简单的分类管理窗口，允许用户：
- 查看所有分类
- 添加新分类
- 删除分类
- 编辑分类名称

---

## 8. 系统设置扩展

### 8.1 添加设置字段
**文件**: `Models/MainWindowModel.cs`
```csharp
// 提醒方式
private bool enablePopupReminder = true;
public bool EnablePopupReminder { get; set; }

private bool enableSoundReminder = true;
public bool EnableSoundReminder { get; set; }

private bool enableTrayReminder = true;
public bool EnableTrayReminder { get; set; }

// 脚本超时时间（秒）
private int scriptTimeout = 30;
public int ScriptTimeout { get; set; }

// 自动备份周期
private BackupCycle autoBackupCycle = BackupCycle.Weekly;
public BackupCycle AutoBackupCycle { get; set; }
```

### 8.2 创建设置窗口或扩展现有窗口
可以创建新的`SystemSettingsWindow`或在`ThemeSettingsWindow`中添加新的Tab页。

---

## 实现检查清单

完成每个功能后，请在对应的状态文档中更新状态标记：

- [ ] 优先级字段和样式
- [ ] 关联操作功能
- [ ] 历史记录功能
- [ ] 数据备份与恢复
- [ ] 遮盖层位置选择
- [ ] 折叠/展开功能
- [ ] 分类标签管理
- [ ] 系统设置扩展

---

**注意事项**：
1. 每次修改数据库结构后记得更新迁移
2. 添加新功能时保持代码风格一致
3. 充分测试每个功能
4. 更新用户文档
