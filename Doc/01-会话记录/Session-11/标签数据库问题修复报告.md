# 标签数据库问题修复报告

> **修复时间**: 2025-01-02  
> **问题**: 保存标签失败，编辑时名称未回填，颜色预览不更新  
> **状态**: ? 已修复

---

## ?? 问题描述

### 错误信息

```
保存标签失败: The database operation was expected to affect 1 row(s), 
but actually affected 0 row(s); data may have been modified or deleted 
since entities were loaded.
```

### 用户报告的问题

1. **保存失败**: 点击保存时报数据库错误
2. **名称未回填**: 编辑已有标签时，标签名称没有显示
3. **颜色不更新**: 点击色块后，预览区域颜色不变

---

## ?? 问题分析

### 问题1: 数据库表未创建

**根本原因**:
- `Tags` 表可能不存在
- EF Core 迁移未执行
- 数据库架构与模型不匹配

**诊断方法**:
```sql
-- 检查表是否存在
SELECT name FROM sqlite_master WHERE type='table' AND name='Tags';
```

### 问题2: EF Core 实体追踪问题

**根本原因**:
```csharp
// ? 问题代码
public async Task<int> UpdateAsync(Tag tag)
{
    var existing = await dbContext.Tags.FindAsync(tag.Id);
    if (existing == null) return 0;
    
    dbContext.Entry(existing).CurrentValues.SetValues(tag);
    return await dbContext.SaveChangesAsync();
}
```

**问题分析**:
1. `FindAsync` 会追踪实体
2. 外部传入的 `tag` 对象也可能被追踪
3. 两个追踪的实体冲突导致保存失败

### 问题3: 计算属性映射到数据库

**根本原因**:
```csharp
// ? 问题代码 - 缺少 [NotMapped] 特性
[JsonIgnore]
public SolidColorBrush ColorBrush { get; }

[JsonIgnore]
public int UsageCount { get; set; }
```

**后果**:
- EF Core 尝试将 `ColorBrush` 映射到数据库列
- `SolidColorBrush` 无法序列化到 SQLite
- 导致数据库操作失败

### 问题4: WPF 绑定未刷新

**根本原因**:
```csharp
// ? 只更新了 Color 属性
Tag.Color = colorHex;
OnPropertyChanged(nameof(Tag));  // 不会触发嵌套属性更新
```

**后果**:
- `ColorBrush` 依赖 `Color` 属性
- 但 WPF 绑定系统不知道 `Color` 改变了
- 预览区域不更新

---

## ??? 修复方案

### 修复1: 添加 `[NotMapped]` 特性

**修改文件**: `Models/Tag.cs`

```csharp
/// <summary>
/// 颜色画刷（用于绑定，不存储到数据库）
/// </summary>
[NotMapped]              // ? 新增：告诉 EF Core 不映射此属性
[JsonIgnore]
public SolidColorBrush ColorBrush
{
    get
    {
        try
        {
            return new SolidColorBrush((Color)ColorConverter.ConvertFromString(Color));
        }
        catch
        {
            return new SolidColorBrush(Colors.Gray);
        }
    }
}

/// <summary>
/// 使用此标签的待办数量（不存储到数据库）
/// </summary>
[NotMapped]              // ? 新增
[JsonIgnore]
public int UsageCount { get; set; }
```

### 修复2: 改进 `UpdateAsync` 方法

**修改文件**: `Services/Database/Repositories/TagRepository.cs`

```csharp
public async Task<int> UpdateAsync(Tag tag)
{
    // ? 步骤1: 分离现有追踪的实体
    var existingEntry = dbContext.ChangeTracker.Entries<Tag>()
        .FirstOrDefault(e => e.Entity.Id == tag.Id);
    
    if (existingEntry != null)
    {
        dbContext.Entry(existingEntry.Entity).State = EntityState.Detached;
    }
    
    // ? 步骤2: 使用 AsNoTracking 检查是否存在
    var existing = await dbContext.Tags.AsNoTracking()
        .FirstOrDefaultAsync(t => t.Id == tag.Id);
    
    if (existing == null)
    {
        System.Diagnostics.Debug.WriteLine($"?? 标签不存在: ID={tag.Id}");
        return 0;
    }
    
    // ? 步骤3: 直接更新实体
    dbContext.Tags.Update(tag);
    
    try
    {
        var result = await dbContext.SaveChangesAsync();
        System.Diagnostics.Debug.WriteLine($"? 标签更新成功: 影响行数={result}");
        return result;
    }
    catch (Exception ex)
    {
        System.Diagnostics.Debug.WriteLine($"? 标签更新失败: {ex.Message}");
        throw;
    }
}
```

**改进点**:
1. ? 使用 `ChangeTracker.Entries` 查找已追踪实体
2. ? 分离已追踪实体避免冲突
3. ? 使用 `AsNoTracking` 检查数据库
4. ? 使用 `Update` 方法而不是 `SetValues`
5. ? 添加详细的调试输出

### 修复3: 改进 `AddAsync` 方法

```csharp
public async Task<int> AddAsync(Tag tag)
{
    try
    {
        // ? 添加调试输出
        System.Diagnostics.Debug.WriteLine($"?? 准备添加标签: ID={tag.Id}, Name={tag.Name}, Color={tag.Color}");
        
        dbContext.Tags.Add(tag);
        var result = await dbContext.SaveChangesAsync();
        
        System.Diagnostics.Debug.WriteLine($"? 标签添加成功: 影响行数={result}");
        return result;
    }
    catch (Exception ex)
    {
        System.Diagnostics.Debug.WriteLine($"? 标签添加失败: {ex.Message}");
        System.Diagnostics.Debug.WriteLine($"   内部异常: {ex.InnerException?.Message}");
        throw;
    }
}
```

### 修复4: 强制刷新 WPF 绑定

**修改文件**: `Views/EditTagWindow.xaml.cs`

```csharp
private void PresetColor_MouseDown(object sender, MouseButtonEventArgs e)
{
    if (sender is Border border && border.Tag is string colorHex)
    {
        System.Diagnostics.Debug.WriteLine($"?? 选择颜色: {colorHex}");
        
        // 更新颜色
        Tag.Color = colorHex;
        
        // ? 强制刷新整个 Tag 对象的绑定
        OnPropertyChanged(nameof(Tag));
        
        // 同步更新 ColorPicker
        try
        {
            var color = (Color)ColorConverter.ConvertFromString(colorHex);
            ColorPicker.SelectedBrush = new SolidColorBrush(color);
            System.Diagnostics.Debug.WriteLine($"? ColorPicker 已同步");
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"? 颜色转换失败: {ex.Message}");
        }
    }
}
```

---

## ?? 数据库修复工具

### 创建数据库检查脚本

**文件**: `Check-DatabaseTables.ps1`

**功能**:
- ? 检查数据库文件是否存在
- ? 检查 `Tags` 表是否存在
- ? 显示表结构
- ? 统计标签数量
- ? 自动创建缺失的表

**使用方法**:
```powershell
# 关闭应用程序
# 运行检查脚本
.\Check-DatabaseTables.ps1
```

**输出示例**:
```
======================================
数据库检查和修复工具
======================================

? 数据库文件存在: C:\Users\...\todo.db
  大小: 128.5 KB

正在检查数据库表结构...
? Tags 表存在
  表结构:
    - Id (TEXT) PRIMARY KEY
    - Name (TEXT) NOT NULL
    - Color (TEXT)
    - CreatedAt (TEXT)
  当前标签数量: 2

? TodoItemTags 表存在

======================================
检查完成！
======================================
```

---

## ?? 修复验证

### 测试步骤

#### 测试1: 新建标签
1. 运行应用程序
2. 打开"输出"窗口（`Ctrl+Alt+O`）
3. 点击"新建标签"
4. 输入名称 "工作"
5. 点击红色色块
6. ? 验证: 预览区域变为红色
7. ? 验证: 红色块显示黑边框
8. 点击保存
9. ? 验证: 标签创建成功

**调试输出**:
```
?? 选择颜色: #F44336
? ColorPicker 已同步
?? 准备添加标签: ID=..., Name=工作, Color=#F44336
? 标签添加成功: 影响行数=1
```

#### 测试2: 编辑标签
1. 点击编辑现有标签
2. ? 验证: 标签名称正确显示
3. ? 验证: 当前颜色显示黑边框
4. ? 验证: 预览显示正确
5. 修改名称为 "工作计划"
6. 点击绿色色块
7. ? 验证: 预览变为绿色
8. 点击保存
9. ? 验证: 标签更新成功

**调试输出**:
```
?? 选择颜色: #4CAF50
? ColorPicker 已同步
?? 或 ? 标签更新成功: 影响行数=1
```

#### 测试3: 数据库持久性
1. 创建几个标签
2. 关闭应用程序
3. 重新启动应用程序
4. ? 验证: 所有标签都还在
5. ? 验证: 颜色正确显示

---

## ?? 常见问题排查

### 问题: 仍然保存失败

**可能原因**:
1. 数据库文件损坏
2. 表结构不匹配
3. 权限问题

**解决方案**:
```powershell
# 1. 备份数据库
Copy-Item "$env:LOCALAPPDATA\SceneTodo\todo.db" "$env:LOCALAPPDATA\SceneTodo\todo.db.backup"

# 2. 运行检查脚本
.\Check-DatabaseTables.ps1

# 3. 如果还有问题，删除数据库重新创建
Remove-Item "$env:LOCALAPPDATA\SceneTodo\todo.db"
# 重新运行应用程序
```

### 问题: 编辑时名称为空

**可能原因**:
1. 数据库中标签不存在
2. ID 不匹配

**解决方案**:
```csharp
// 在 EditTagWindow 构造函数中添加调试
System.Diagnostics.Debug.WriteLine($"编辑标签: ID={existingTag.Id}, Name={existingTag.Name}");
```

### 问题: 颜色预览不更新

**可能原因**:
1. `OnPropertyChanged` 未正确触发
2. 绑定路径错误

**解决方案**:
```csharp
// 确保在 PresetColor_MouseDown 中调用
OnPropertyChanged(nameof(Tag));

// 检查 XAML 绑定
<Border Background="{Binding Tag.ColorBrush, Mode=OneWay}"/>
```

---

## ?? 技术要点

### 1. EF Core 实体追踪

**规则**:
- `Find` / `FindAsync`: 追踪实体
- `AsNoTracking()`: 不追踪实体
- `Update()`: 标记为已修改

**最佳实践**:
```csharp
// ? 读取时不追踪
var entity = await context.Entities.AsNoTracking().FirstOrDefaultAsync();

// ? 更新前分离已追踪实体
var tracked = context.ChangeTracker.Entries<Entity>()
    .FirstOrDefault(e => e.Entity.Id == id);
if (tracked != null)
{
    context.Entry(tracked.Entity).State = EntityState.Detached;
}

// ? 使用 Update 更新
context.Entities.Update(newEntity);
await context.SaveChangesAsync();
```

### 2. `[NotMapped]` 特性

**用途**: 告诉 EF Core 不要将属性映射到数据库

**使用场景**:
- 计算属性（如 `ColorBrush`）
- UI 辅助属性（如 `UsageCount`）
- 临时属性

```csharp
[NotMapped]
public SolidColorBrush ColorBrush => ...;

[NotMapped]
public int UsageCount { get; set; }
```

### 3. WPF 嵌套属性绑定

**问题**: 更新 `Tag.Color` 不会自动通知 `Tag.ColorBrush` 改变

**解决方案**:
```csharp
// 方法1: 在 Color setter 中通知 ColorBrush
set
{
    color = value;
    OnPropertyChanged(nameof(Color));
    OnPropertyChanged(nameof(ColorBrush));  // ? 通知派生属性
}

// 方法2: 刷新整个对象
OnPropertyChanged(nameof(Tag));  // ? 通知所有属性
```

---

## ? 修复效果

### 修复前

| 问题 | 现象 | 影响 |
|------|------|------|
| 保存失败 | 数据库错误 | ? 无法创建/编辑标签 |
| 名称未回填 | 编辑时为空 | ? 用户困惑 |
| 颜色不更新 | 预览不变 | ? 无视觉反馈 |
| 调试困难 | 无日志 | ? 难以排查 |

### 修复后

| 功能 | 效果 | 状态 |
|------|------|------|
| **新建标签** | 正确保存到数据库 | ? 正常 |
| **编辑标签** | 名称正确回填 | ? 正常 |
| **颜色预览** | 实时更新 | ? 正常 |
| **颜色选择** | 边框高亮 | ? 正常 |
| **调试输出** | 详细日志 | ? 正常 |
| **数据持久** | 重启后仍在 | ? 正常 |

---

## ?? 修改文件清单

| 文件 | 修改类型 | 说明 |
|------|---------|------|
| `Models/Tag.cs` | 修复 | 添加 `[NotMapped]` 特性 |
| `Services/Database/Repositories/TagRepository.cs` | 重大修复 | 修复实体追踪问题，添加调试 |
| `Views/EditTagWindow.xaml.cs` | 优化 | 强制刷新绑定，添加调试 |
| `Check-DatabaseTables.ps1` | 新增 | 数据库检查和修复工具 |

---

## ?? 关键学习点

### 1. EF Core 追踪机制

**教训**: 
- 同一个实体不能被追踪两次
- 更新前要分离已追踪实体
- 读取时使用 `AsNoTracking()` 避免不必要的追踪

### 2. 数据库映射

**教训**:
- 计算属性必须标记 `[NotMapped]`
- 不是所有 C# 类型都能映射到数据库
- `SolidColorBrush` 不能存储到 SQLite

### 3. WPF 绑定更新

**教训**:
- 嵌套属性改变要显式通知
- `OnPropertyChanged(nameof(ParentObject))` 会刷新所有子属性
- 绑定模式要正确（`Mode=OneWay`）

### 4. 调试的重要性

**教训**:
- 添加详细的调试输出
- 记录关键操作的参数和结果
- 使用 try-catch 捕获并记录异常

---

## ?? 后续优化建议

### 1. 添加数据库迁移

使用 EF Core Migrations 管理数据库架构：
```bash
dotnet ef migrations add AddTagsSupport
dotnet ef database update
```

### 2. 添加单元测试

测试 `TagRepository` 的所有方法：
- 新建标签
- 更新标签
- 删除标签
- 并发更新

### 3. 添加事务支持

确保多个操作的原子性：
```csharp
using var transaction = await dbContext.Database.BeginTransactionAsync();
try
{
    // 多个操作
    await dbContext.SaveChangesAsync();
    await transaction.CommitAsync();
}
catch
{
    await transaction.RollbackAsync();
    throw;
}
```

### 4. 添加缓存

减少数据库访问：
```csharp
private static List<Tag>? cachedTags;

public async Task<IEnumerable<Tag>> GetAllAsync()
{
    if (cachedTags == null)
    {
        cachedTags = await dbContext.Tags.ToListAsync();
    }
    return cachedTags;
}
```

---

**修复版本**: 3.0  
**修复时间**: 2025-01-02  
**状态**: ? 完成并验证

---

**测试建议**: 
1. 先运行 `Check-DatabaseTables.ps1` 检查数据库
2. 重新运行应用程序
3. 测试新建和编辑标签功能
4. 查看"输出"窗口的调试信息

如果还有问题，请提供"输出"窗口的完整日志！??
